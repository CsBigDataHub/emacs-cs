<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?xml-stylesheet type="text/xsl" href="tohtml.xsl"?>

<cheatsheet version="1.0" lang="en" created="2017-09-29">

  <header>
    <title>EMACS Cheatsheet</title>
    <subtitle>For version 25</subtitle>
  </header>

  <body>
    <chapter title="Command line options">
      <it>
        <k>--visit=&lt;filespec&gt; | --file=&lt;filespec&gt; |
        &lt;filespec&gt;</k>
        <f/>
        <d>Open filespec into individual buffers for editing.</d>
      </it>

      <it>
        <k>+row[:column]</k>
        <f/>
        <d>Move point to line number row and (optional) horizontal
        position column in the file (default is +1:1).</d>
      </it>

      <it>
        <k>--insert &lt;file&gt;</k>
        <f/>
        <d>Insert file at the beginning of the buffer.</d>
      </it>

      <it>
        <k>--load &lt;file&gt; | -l &lt;file&gt;</k>
        <f/>
        <d>Execute the Emacs Lisp instructions in file.</d>
      </it>

      <it>
        <k>--g &lt;dimensions&gt; | --geometry &lt;dimensions&gt;</k>
        <f/>
        <d>Set the window's width, height, and position according to
        the given X window dimensions (the default is to make the
        window 80x40 characters).</d>
      </it>

      <it>
        <k>-nw | --no-windows</k>
        <f/>
        <d>In X, don't use an X client window, but open in the current
        terminal window instead. This option doesn't affect console
        sessions.</d>
      </it>
    </chapter>

    <chapter title="Prefixes">
      <it>
        <k>C-c</k>
        <d>Commands particular to the current editing mode</d>
      </it>

      <it>
        <k>C-x</k>
        <d>Commands for files and buffers</d>
      </it>

      <it>
        <k>C-h</k>
        <d>Help commands</d>
      </it>

      <it>
        <k>M-x</k>
        <d>Literal function name</d>
      </it>
    </chapter>

    <chapter title="Buffer and files functions">
      <it>
        <k>C-x C-f</k>
        <f>find-file</f>
        <d>Visit a file.</d>
      </it>
      <it>
        <k>C-x C-s</k>
        <f>save-buffer</f>
        <d>Save current buffer to disk.</d>
      </it>

      <it>
        <k>C-x s</k>
        <f>save-some-buffers</f>
        <d>Ask about saving all unsaved buffers to disk.</d>
      </it>

      <it>
        <k>C-x C-c</k>
        <f>save-buffers-kill-emacs</f>
        <d>Ask about saving all unsaved buffers to disk and exit
        Emacs.</d>
      </it>

      <it>
        <k>C-x C-z | C-z</k>
        <f>suspend-emacs</f>
        <d>Suspend Emacs and make it a background process (press
        <kbd>fg | fg %emacs</kbd> to <i>awake</i> it back.</d>
      </it>

      <it>
        <k>C-x C-b</k>
        <f>list-buffers</f>
        <d>List all buffers.</d>
      </it>

      <it>
        <k>C-x k</k>
        <f>kill-buffer</f>
        <d>Kill a buffer (the current buffer, by default).</d>
      </it>

      <it>
        <k>C-x C-q</k>
        <f>vc-toggle-read-only</f>
        <d>Toggle read-only status on the current buffer (and perform
        version control if applicable).</d>
      </it>

      <it>
        <k>C-x i</k>
        <f>insert-file</f>
        <d>Insert the contents of a file at point.</d>
      </it>
    </chapter>

    <chapter title="Movement and navigation">
      <it>
        <k>C-p | UpArrow</k>
        <f>previous-line</f>
        <d>Move point up to the previous line.</d>
      </it>

      <it>
        <k>C-n | DownArrow</k>
        <f>next-line</f>
        <d>Move point down to the next line.</d>
      </it>

      <it>
        <k>C-f | RightArrow</k>
        <f>forward-char</f>
        <d>Move point forward to the next character.</d>
      </it>

      <it>
        <k>C-b | LeftArrow</k>
        <f>back-char</f>
        <d>Move point backward to the previous character.</d>
      </it>

      <it>
        <k>M-f | C-RightArrow</k>
        <f>forward-word</f>
        <d>Move point forward to the next word.</d>
      </it>

      <it>
        <k>M-b | C-LeftArrow</k>
        <f>backward-word</f>
        <d>Move point backward to the previous word.</d>
      </it>

      <it>
        <k>C-v | PgDn</k>
        <f>scroll-up</f>
        <d>Scroll the text upward by a screen.</d>
      </it>

      <it>
        <k>M-v | PgUp</k>
        <f>scroll-down</f>
        <d>Scroll the text downward by a screen.</d>
      </it>

      <it>
        <k>C-Home</k>
        <f>beginning-of-buffer</f>
        <d>Move point to the beginning of the buffer. (On some
        versions, this key is defined by default to move to the
        beginning of the current line.)</d>
      </it>

      <it>
        <k>C-End</k>
        <f>end-of-buffer</f>
        <d>Move point to the end of the buffer. (On some versions,
        this key is defined by default to move to the end of the
        current line.)</d>
      </it>

      <it>
        <k>Home | C-a</k>
        <f>beginning-of-line</f>
        <d>Move point to the beginning of the line.</d>
      </it>

      <it>
        <k>End | C-e</k>
        <f>end-of-line</f>
        <d>Move point to the end of the line.</d>
      </it>

      <it>
        <k>M-a</k>
        <f>beginning-of-sentence</f>
        <d>Move point to the beginning of the sentence.</d>
      </it>

      <it>
        <k>M-e</k>
        <f>end-of-sentence</f>
        <d>Move point to the end of the sentence.</d>
      </it>

      <it>
        <k>C-{</k>
        <f>beginning-of-paragraph</f>
        <d>Move point to the beginning of the paragraph.</d>
      </it>

      <it>
        <k>C-}</k>
        <f>end-of-paragraph</f>
        <d>Move point to the end of the paragraph.</d>
      </it>
    </chapter>

    <chapter title="Common editing commands">
      <it>
        <k>Ins</k>
        <f>overwrite-mode</f>
        <d>Toggle overwrite mode (default is off).</d>
      </it>

      <it>
        <k>Backspace | Del</k>
        <f>delete-backward-char</f>
        <d>Delete the character before point.</d>
      </it>

      <it>
        <k>C-d</k>
        <f>delete-char</f>
        <d>Delete the character at point.</d>
      </it>

      <it>
        <k>M-d</k>
        <f>kill-word</f>
        <d>Delete the characters from point forward to the end of the
        word.</d>
      </it>

      <it>
        <k>M-Backspace | M-Del</k>
        <f>backward-kill-word</f>
        <d>Delete the characters from point backward to the beginning
        of the word.</d>
      </it>

      <it>
        <k>C-_</k>
        <f>undo</f>
        <d>Undo your last typing or action.</d>
      </it>

      <it>
        <k>C-q[CHAR] or [NUM]</k>
        <f>quoted-insert</f>
        <d>Insert, at point, the literal character keypress or the
        character whose octal value is XXX.</d>
      </it>

      <it>
        <k>C-u[NUM][COMMAND]</k>
        <f>universal-argument</f>
        <d>Execute command a total of number (default 4) times in
        succession.</d>
      </it>
    </chapter>

    <chapter title="Functions for marking and killing text">
      <it>
        <k>C-Space</k>
        <f>set-mark-command</f>
        <d>Set the mark at point.</d>
      </it>

      <it>
        <k>C-k</k>
        <f>kill-line</f>
        <d>Kill all text from point to the end of the line.</d>
      </it>

      <it>
        <k>C-w</k>
        <f>kill-region</f>
        <d>Kill the region.</d>
      </it>

      <it>
        <k>M-w</k>
        <f>kill-ring-save</f>
        <d>Save the region in the kill ring, but don't kill it.</d>
      </it>

      <it>
        <k>C-y</k>
        <f>yank</f>
        <d>Yank text from the kill ring.</d>
      </it>
    </chapter>

    <chapter title="Text mode key bindings">
      <it>
        <k>Esc</k>
        <f/>
        <d>Prefix for mode-specific commands</d>
      </it>

      <it>
        <k>Esc Tab | M-Tab</k>
        <f>ispell-complete-word</f>
        <d/>
      </it>

      <it>
        <k>Esc S | M-S</k>
        <f>center-paragraph</f>
        <d/>
      </it>

      <it>
        <k>Esc s | M-s</k>
        <f>center-line</f>
        <d/>
      </it>
    </chapter>

    <chapter title="Text manipulation commands">
      <it>
        <k>C-x C-i | C-x Tab</k>
        <f>indent-rigidly</f>
        <d>This command indents lines in the region (or at point).</d>
      </it>

      <it>
        <k/>
        <f>fill-region</f>
        <d>This command fills all paragraphs in the region.</d>
      </it>

      <it>
        <k>M-q</k>
        <f>fill-paragraph</f>
        <d>This command fills the single paragraph at point.</d>
      </it>

      <it>
        <k>M-\</k>
        <f>delete-horizontal-space</f>
        <d>This command removes any horizontal space to the right and
        left of point.</d>
      </it>

      <it>
        <k>C-o</k>
        <f>open-line</f>
        <d>This command opens a new line of vertical space below
        point, without moving point.</d>
      </it>

      <it>
        <k>C-t</k>
        <f>transpose-chars</f>
        <d>This command transposes the single characters to the right
        and left of point.</d>
      </it>

      <it>
        <k>M-t</k>
        <f>transpose-words</f>
        <d>This command transposes the single words to the right and
        left of point.</d>
      </it>

      <it>
        <k>C-x C-t</k>
        <f>transpose-lines</f>
        <d>This command transposes the line at point with the line
        before it.</d>
      </it>

      <it>
        <k>M-^</k>
        <f>delete-indentation</f>
        <d>This command joins the line at point with the previous
        line. Preface with <kbd>C-1</kbd> to join the line at point
        with the next line.</d>
      </it>

      <it>
        <k>M-u</k>
        <f>uppercase-word</f>
        <d>This command converts the text at point to the end of the
        word to uppercase letters.</d>
      </it>

      <it>
        <k>M-l</k>
        <f>downcase-word</f>
        <d>This command converts the text at point to the end of the
        word to lowercase letters.</d>
      </it>

      <it>
        <k>C-x C-l</k>
        <f>downcase-region</f>
        <d>This command converts the region to lowercase letters.</d>
      </it>

      <it>
        <k>C-x C-u</k>
        <f>upcase-region</f>
        <d>This command converts the region to uppercase letters.</d>
      </it>
    </chapter>

    <chapter title="Search and replace commands">
      <it>
        <k>C-s [STRING] [C-w] [C-y]</k>
        <f>isearch-forward</f>
        <d>Incrementally search forward through the buffer for string
        (default is the last search string you gave, if any);
        <kbd>C-w</kbd> uses the text from point forward to the end of
        the word and <kbd>C-y</kbd> uses everything from point to the
        end of the line.</d>
      </it>

      <it>
        <k>C-r [STRING] [C-w] [C-y]</k>
        <f>isearch-backward</f>
        <d>Incrementally search backward through the buffer for string
        (default is the last search string you gave, if any);
        <kbd>C-w</kbd> uses the text from point forward to the end of
        the word, and <kbd>C-y</kbd> uses everything from point to the
        end of the line.</d>
      </it>

      <it>
        <k>C-s Enter C-w [WORD OR PHRASE]</k>
        <f>word-search-forward</f>
        <d>Search forward through the buffer for the given word or
        phrase, regardless of spacing.</d>
      </it>

      <it>
        <k>C-r Enter C-w [WORD OR PHRASE]</k>
        <f>word-search-backward</f>
        <d>Search backward through the buffer for the given word or
        phrase, regardless of spacing.</d>
      </it>

      <it>
        <k>C-M-s</k>
        <f>isearch-forward-regexp</f>
        <d>Incrementally search forward through the buffer for a given
        regular expression.</d>
      </it>

      <it>
        <k>C-M-r</k>
        <f>isearch-backward-regexp</f>
        <d>Incrementally search backward through the buffer for a
        given regular expression.</d>
      </it>

      <it>
        <k/>
        <f>replace-string</f>
        <d>Search for a given string from point to the end of the
        buffer and replace it with a given string.</d>
      </it>

      <it>
        <k/>
        <f>replace-regexp</f>
        <d>Search for a given regular expression from point to the end
        of the buffer and replace it with a given string.</d>
      </it>

      <it>
        <k>M-%</k>
        <f>query-replace</f>
        <d>Search for a given string from point to the end of the
        buffer and, in each instance, query to replace it with a
        given string.</d>
      </it>

      <it>
        <k>C-M-%</k>
        <f>query-replace-regexp</f>
        <d>Search for a given regular expression from point to the end
        of the buffer and, in each instance, query to replace it
        with a given string.</d>
      </it>
    </chapter>

    <chapter title="Commands for using rectangles">
      <it>
        <k>C-space</k>
        <f>set-mark-command</f>
        <d>Marks one corner of a rectangle (point marks the opposite
        corner).</d>
      </it>

      <it>
        <k>C-x r k</k>
        <f>kill-rectangle</f>
        <d>Kills the current rectangle and saves it in a special
        rectangle buffer.</d>
      </it>

      <it>
        <k>C-x r d</k>
        <f>delete-rectangle</f>
        <d>Deletes the current rectangle and doesn't save it for
        yanking.</d>
      </it>

      <it>
        <k>C-x r c</k>
        <f>clear-rectangle</f>
        <d>Clears the current rectangle, replacing the entire area
        with whitespace.</d>
      </it>

      <it>
        <k>C-x r o</k>
        <f>open-rectangle</f>
        <d>Opens the current rectangle, filling the entire area with
        whitespace and moving all text from the rectangle to the
        right.</d>
      </it>

      <it>
        <k>C-x r y</k>
        <f>yank-rectangle</f>
        <d>Yanks the contents of the last-killed rectangle at point,
        moving all existing text to the right.</d>
      </it>
    </chapter>

    <chapter title="Advanced mark and selection commands">
      <it>
        <k>C-u C-space</k>
        <f>pop-to-mark-command</f>
        <d>Moves to the previous mark in the mark ring.</d>
      </it>

      <it>
        <k>C-x C-x</k>
        <f>exchange-point-and-mark</f>
        <d>Swaps the location of point and the mark.</d>
      </it>

      <it>
        <k>M-@</k>
        <f>mark-word</f>
        <d>Marks all text from point to the end of the current
        word.</d>
      </it>

      <it>
        <k>M-h</k>
        <f>mark-paragraph</f>
        <d>Marks the current paragraph, regardless of the location of
        point.</d>
      </it>

      <it>
        <k/>
        <f>transient-mark-mode</f>
        <d>Toggles Transient Mark mode.</d>
      </it>

      <it>
        <k>C-x h</k>
        <f>mark-whole-buffer</f>
        <d>Marks the entire buffer, regardless of the location of
        point.</d>
      </it>
    </chapter>

    <chapter title="Advanced kill and yank commands">
      <it>
        <k>[NUM] C-k</k>
        <f>kill-line</f>
        <d>Kills integer number of lines. If 0, kills from point to
        the beginning of the line; if negative, kills in reverse (not
        sure for version 25).</d>
      </it>

      <it>
        <k>M-k</k>
        <f>kill-sentence</f>
        <d>Kills from point to the end of the sentence.</d>
      </it>

      <it>
        <k>M-z</k>
        <f>zap-to-char</f>
        <d>Zaps all text from point to the specified character.</d>
      </it>

      <it>
        <k>M-y</k>
        <f>yank-pop</f>
        <d>Moves to the next slot in the kill ring.</d>
      </it>

      <it>
        <k>[NUM] C-y</k>
        <f>yank</f>
        <d>Yanks the specified slot in the kill ring.</d>
      </it>
    </chapter>

    <chapter title="Registers commands">
      <it>
        <k>C-x r space X</k>
        <f>point-to-register</f>
        <d>Save point to register X.</d>
      </it>

      <it>
        <k>C-x r s X</k>
        <f>copy-to-register</f>
        <d>Save the region to register X.</d>
      </it>

      <it>
        <k>C-x r r X</k>
        <f>copy-rectangle-to-register</f>
        <d>Save the selected rectangle to register X.</d>
      </it>

      <it>
        <k/>
        <f>view-register</f>
        <d>View the contents of a given register.</d>
      </it>

      <it>
        <k>C-x r j X</k>
        <f>jump-to-register</f>
        <d>Move point to the location given in register X.</d>
      </it>

      <it>
        <k>C-x r i X</k>
        <f>insert-register</f>
        <d>Insert the contents of register X at point.</d>
      </it>
    </chapter>

    <chapter title="Bookmarks commands">
      <it>
        <k>C-x r m Bookmark</k>
        <f>bookmark-set</f>
        <d>Set a bookmark named Bookmark.</d>
      </it>

      <it>
        <k>C-x r l</k>
        <f>bookmarks-bmenu-list</f>
        <d>List all saved bookmarks.</d>
      </it>

      <it>
        <k/>
        <f>bookmark-delete</f>
        <d>Delete a bookmark.</d>
      </it>

      <it>
        <k>C-x r b Bookmark</k>
        <f>bookmark-jump</f>
        <d>Jump to the location set in the bookmark named
        Bookmark.</d>
      </it>

      <it>
        <k/>
        <f>bookmark-save</f>
        <d>Save all bookmarks to the bookmark file, ~/.emacs.bmk.</d>
      </it>
    </chapter>

    <chapter title="Window-manipulation commands">
      <it>
        <k>C-x 2</k>
        <f>split-window-vertically</f>
        <d>Split the current window in half across the middle,
        stacking the new buffers vertically.</d>
      </it>

      <it>
        <k>C-x 4 b</k>
        <f>switch-to-buffer-other-window</f>
        <d>Split the current window in half vertically, prompting for
        the buffer to use the bottom window and making that the active
        window.</d>
      </it>

      <it>
        <k>C-x 4 C-o</k>
        <f>display-buffer</f>
        <d>Display a buffer in another window, prompting for the
        buffer to use the other window but keeping the current window
        active. (If only one window exists, then split the window
        vertically to display the other buffer.)</d>
      </it>

      <it>
        <k>C-x 4 f</k>
        <f>find-file-other-window</f>
        <d>Open a new file in a new buffer, drawing it in a new
        vertical window.</d>
      </it>

      <it>
        <k>C-x 4 r</k>
        <f>find-file-read-only-other-window</f>
        <d>Open a new file in a new read-only buffer, drawing it in a
        new vertical window.</d>
      </it>

      <it>
        <k>C-M-v</k>
        <f>scroll-other-window</f>
        <d>Scroll to the window that would be the next one to switch
        to with <kbd>C-x o</kbd>.</d>
      </it>

      <it>
        <k/>
        <f>scroll-all</f>
        <d>Toggle the scroll-all minor mode. When it's on, all windows
        displaying the buffer in the current window are scrolled
        simultaneously and in equal, relative amounts.</d>
      </it>

      <it>
        <k>C-x o</k>
        <f>other-window</f>
        <d>Move the cursor to the next window, and make it the active
        window.</d>
      </it>

      <it>
        <k>C-x 0</k>
        <f>delete-window</f>
        <d>Delete the current window, and move the cursor to the
        window that would be the next one to switch to with
        <kbd>C-x o</kbd>.</d>
      </it>

      <it>
        <k>C-x 1</k>
        <f>delete-other-windows</f>
        <d>Delete all windows except the current window.</d>
      </it>

      <it>
        <k>C-x 4 0</k>
        <f>kill-buffer-and-window</f>
        <d>Delete the current window, and kill its buffer.</d>
      </it>

      <it>
        <k>C-x 3</k>
        <f>split-window-horizontally</f>
        <d>Split the current window in half down the middle, stacking
        the new buffers horizontally.</d>
      </it>

      <it>
        <k/>
        <f>follow-mode</f>
        <d>Toggle follow, a minor mode. When it's on in a buffer, all
        windows displaying the buffer are connected into a large
        virtual window.</d>
      </it>

      <it>
        <k>C-x ^</k>
        <f>enlarge-window</f>
        <d>Make the current window taller by a line; preceded by a
        negative, this makes the current window shorter by a line.</d>
      </it>

      <it>
        <k>C-x }</k>
        <f>shrink-window-horizontally</f>
        <d>Make the current active window thinner by a single
        column.</d>
      </it>

      <it>
        <k>C-x {</k>
        <f>enlarge-window-horizontally</f>
        <d>Make the current active window wider by a single
        column.</d>
      </it>

      <it>
        <k>C-x -</k>
        <f>shrink-window-if-larger-than-buffer</f>
        <d>Reduce the current active window to the smallest possible
        size for the buffer it contains.</d>
      </it>

      <it>
        <k>C-x +</k>
        <f>balance-windows</f>
        <d>Balance the size of all windows, making them approximately
        equal.</d>
      </it>

      <it>
        <k/>
        <f>compare-windows</f>
        <d>Compare the current window with the next window, beginning
        with point in both windows and moving point in both buffers to
        the first character that differs until reaching the end of the
        buffer.</d>
      </it>
    </chapter>

    <chapter title="nXML mode">
      <it>
        <k>C-c C-n</k>
        <f>rng-next-error</f>
        <d>Move to the next location where the document
        structure is not valid. If the document isn't valid, the
        cursor will jump to the probable error, and display a message
        in the minibuffer explaining what it doesn't like. If the
        document is valid from the cursor to the end of the file, the
        message “No more errors” appears in the minibuffer. To
        validate the entire document, move to the top of the document
        with <kbd>M-&lt;</kbd> and then use this key sequence. If it
        says “No more errors” with point at the top of the file, the
        entire file is valid; otherwise it will jump the cursor to the
        next invalid content.</d>
      </it>

      <it>
        <k>C-c C-v</k>
        <f>rng-validate-mode</f>
        <d>Turn validation on or off. If validation is turned on, in
        the status line's mode area you will see either “nXML Valid”
        or “nXML Invalid”. If validation is turned off, neither word
        will appear after “nXML” in the mode line. You may want to
        turn validation off during serious document surgery, then turn
        it back on when you think it's valid again.</d>
      </it>

      <it>
        <k>tab</k>
        <f>indent-for-tab-command</f>
        <d>Indent the current line according to the level of nested
        block tags. The indentation is two spaces per level.</d>
      </it>

      <it>
        <k>M-C-\</k>
        <f>indent-region</f>
        <d>Indent all the lines in the region using the same process
        as for tab.</d>
      </it>

      <it>
        <k>C-c C-f</k>
        <f>nxml-finish-element</f>
        <d>Insert an end tag for whatever element the cursor is
        in. This works whether you are still inside the start tag or
        in the content.</d>
      </it>

      <it>
        <k>C-c C-i</k>
        <f>nxml-balanced-close-start-tag-inline</f>
        <d>Used when you have finished the start tag of an
        inline element, up to but not including the closing
        “&gt;”. This command adds the closing “&gt;” and an end tag,
        and then places the cursor between the tags so you can type
        the content.</d>
      </it>

      <it>
        <k>C-c C-b</k>
        <f>nxml-balanced-close-start-tag-block</f>
        <d>Like <kbd>C-c C-i</kbd>, but used with block elements. The
        command adds the closing “&gt;”, then a blank line, then an
        end tag on yet another separate line. The cursor is left
        indented at the proper level on the central blank line.</d>
      </it>

      <it>
        <k>M-q</k>
        <f>fill-paragraph</f>
        <d>Reformat the paragraph containing the cursor. This works
        best if the content does not start on the same line as the
        start tag.</d>
      </it>

      <it>
        <k>C-c C-x</k>
        <f>nxml-insert-xml-declaration</f>
        <d>Inserts an XML processing instruction at the top of the
        file.</d>
      </it>

      <it>
        <k>M-C-f</k>
        <f>forward-sexp</f>
        <d>Move forward over tag. If point is not inside a
        tag, it moves to a position just before the next tag. If point
        is inside a start tag, it jumps to a position just before the
        closing “&gt;”. If point is inside an end tag, it moves just
        past the end tag.</d>
      </it>

      <it>
        <k>M-C-b</k>
        <f>backward-sexp</f>
        <d>Move backward over tag. If point is not inside a
        tag, it moves just after the previous start tag. If point is
        inside a start tag, it jumps to a position just after the
        starting “&lt;”. If point is inside an end tag, it moves just
        before that tag.</d>
      </it>

      <it>
        <k>M-C-n</k>
        <f>nxml-forward-element</f>
        <d>Move the cursor to the end of the next element.</d>
      </it>

      <it>
        <k>M-C-p</k>
        <f>nxml-backward-element</f>
        <d>Move the cursor before the previous element.</d>
      </it>

      <it>
        <k>M-C-d</k>
        <f>nxml-down-element</f>
        <d>Move the cursor to the next included element after point,
        to a position just after the start tag; d is for “down.”</d>
      </it>

      <it>
        <k>M-C-u</k>
        <f>nxml-backward-up-element</f>
        <d>Move the cursor to a position just before the start tag of
        the element containing point; u is for “up.”</d>
      </it>

      <it>
        <k>C-c C-o C-d</k>
        <f>nxml-hide-subheadings</f>
        <d>Hide the children of the current element, as in emacs
        outline-mode.</d>
      </it>

      <it>
        <k>C-c C-o C-s</k>
        <f>nxml-hide-subheadings</f>
        <d>Reverses the action of <kbd>C-c C-o C-d</kbd>, revealing
        the children of the current element.</d>
      </it>
    </chapter>

    <chapter title="Things you should never know about">
      <it>
        <k>M-x dunnet</k>
        <f/>
        <d>Dungeon</d>
      </it>

      <it>
        <k>M-x tetris</k>
        <f/>
        <d>Tetris</d>
      </it>

      <it>
        <k>M-x blackbox</k>
        <f/>
        <d>Hide &amp; seek</d>
      </it>

      <it>
        <k>M-x doctor</k>
        <f/>
        <d>Psychotherapy</d>
      </it>

      <it>
        <k>M-x gomoku</k>
        <f/>
        <d>Gomoku</d>
      </it>

      <it>
        <k>M-x landmark</k>
        <f/>
        <d>Robot game</d>
      </it>

      <it>
        <k>M-x snake</k>
        <f/>
        <d>The snake game</d>
      </it>

      <it>
        <k>M-x solitaire</k>
        <f/>
        <d>Peg solitaire</d>
      </it>
    </chapter>

  </body>

  <footer>
    <line>Copyright (C) 2017 Pete Za Sayari</line>
    <line>&lt;petezasayari@gmail.com&gt;</line>
    <line></line>
    <line>Released under the terms of the GNU General Public License</line>
    <line>version 3 or later.</line>
    <line></line>
    <line>For more Emacs documentation see the Emacs distribution or
    http://www.gnu.org/software/emacs</line>
    <line>For the XML-XSLT source for this cheat sheet see
    https://github.com/PeteZaSayari/emacs-cs</line>
  </footer>

</cheatsheet>

<!-- Dictionary

  <it>  =   <item>
  <k>   =   <key>
  <f>   =   <function>
  <d>   =   <description>

-->

